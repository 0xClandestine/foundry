use solar_ast::{
    ast::{BinOp, BinOpKind, Expr, ExprKind},
    visit::Visit,
};

use crate::DivideBeforeMultiply;
impl<'ast> Visit<'ast> for DivideBeforeMultiply {
    fn visit_expr(&mut self, expr: &'ast Expr<'ast>) {
        // Check if the current expression is a binary operation with multiplication
        if let ExprKind::Binary(left_expr, BinOp { kind: BinOpKind::Mul, .. }, _) = &expr.kind {
            let mut curr_expr = left_expr;

            // Traverse the left-hand expressions
            loop {
                match &curr_expr.kind {
                    // If the expression is a binary operation, inspect its kind
                    ExprKind::Binary(inner_expr, binop, _) => match binop.kind {
                        // Found division, push the span and stop traversal
                        BinOpKind::Div => {
                            self.items.push(curr_expr.span);
                            break;
                        }
                        // Continue traversing if it's another multiplication
                        BinOpKind::Mul => {
                            curr_expr = inner_expr;
                        }
                        // Stop if it's any other binary operator
                        _ => {
                            break;
                        }
                    },

                    // Handle tuple expressions that contain one nested expression
                    ExprKind::Tuple([Some(inner_expr)]) => {
                        curr_expr = inner_expr;
                    }

                    // Stop for any other kind of expression
                    _ => {
                        break;
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod test {
    use solar_ast::{ast, visit::Visit};
    use solar_interface::{ColorChoice, Session};
    use std::path::Path;

    use crate::DivideBeforeMultiply;

    #[test]
    fn test_divide_before_multiply() -> eyre::Result<()> {
        let sess = Session::builder().with_buffer_emitter(ColorChoice::Auto).build();

        let _ = sess.enter(|| -> solar_interface::Result<()> {
            let arena = ast::Arena::new();

            let mut parser = solar_parse::Parser::from_file(
                &sess,
                &arena,
                Path::new("testdata/DivideBeforeMultiply.sol"),
            )
            .expect("TODO:");

            // Parse the file.
            let ast = parser.parse_file().map_err(|e| e.emit()).expect("TODO:");

            dbg!(&ast);

            let mut pattern = DivideBeforeMultiply::default();
            pattern.visit_source_unit(&ast);

            assert_eq!(pattern.items.len(), 0);

            Ok(())
        });

        Ok(())
    }
}
